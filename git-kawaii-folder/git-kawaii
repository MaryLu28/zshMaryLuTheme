#!/usr/bin/env bash
# git-kawaii: drop-in wrapper for Git (boxes + optional lolcat)
# - Recognized commands:
#     kawaii-status, kawaii-merge, kawaii-rebase
# - Any other subcommand → forwarded to real `git`
set -euo pipefail

has() { command -v "$1" >/dev/null 2>&1; }
box_width() { printf '%s' "${1:-${COLUMNS:-80}}"; }

print_box() {
  # print_box <color> <title> <minWidth> -- <lines...>
  local color="$1" title="$2" width; width="$(box_width "$3")"
  shift 3
  while [[ "${1:-}" != "--" && "$#" -gt 0 ]]; do shift; done
  shift || true
  local body=""
  if [[ "$#" -gt 0 ]]; then body=$(printf '• %s\n' "$@"); else body="(empty)"; fi

  local code=""
  case "$color" in
    red) code="31" ;; green) code="32" ;; yellow) code="33" ;; cyan) code="36" ;;
    *) code="" ;;
  esac

  if [[ -n "$code" ]]; then
    { printf "\033[1m%s\033[0m\n%s\n" "$title" "$body"; } \
      | boxes -d ansi -s "$width" \
      | sed $'s/^/\x1b['"$code"$'m/; s/$/\x1b[0m/'
  else
    { printf "%s\n%s\n" "$title" "$body"; } | boxes -d ansi -s "$width"
  fi
}

do_merge() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  local width out rc; width="$(box_width)"
  out="$(git -c color.ui=always merge "$@" 2>&1)" || rc=$? || true
  rc=${rc:-0}

  if [[ $rc -eq 0 ]]; then
    printf "%s\n" "$out" | boxes -d ansi -s "$width"
    if has lolcat; then
      printf "✨ Merge successful — no conflicts! 🎉\n" | boxes -d whirly | lolcat
    else
      printf "✨ Merge successful — no conflicts! 🎉\n" | boxes -d whirly
    fi
  else
    if grep -qi 'conflict' <<<"$out"; then
      printf "%s\n" "$out" \
        | sed $'s/^/\x1b[31m/; s/$/\x1b[0m/' | boxes -d ansi -s "$width"
    else
      printf "%s\n" "$out"
    fi
  fi
  return "$rc"
}

do_rebase() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  local width out rc; width="$(box_width)"
  out="$(git -c color.ui=always rebase "$@" 2>&1)" || rc=$? || true
  rc=${rc:-0}

  if [[ $rc -eq 0 ]]; then
    printf "%s\n" "$out" | boxes -d ansi -s "$width"
    if has lolcat; then
      printf "✨ Rebase successful — no conflicts! 🎉\n" | boxes -d whirly | lolcat
    else
      printf "✨ Rebase successful — no conflicts! 🎉\n" | boxes -d whirly
    fi
  else
    if grep -qi -e 'conflict' -e 'could not apply' <<<"$out"; then
      printf "%s\n" "$out" \
        | sed $'s/^/\x1b[31m/; s/$/\x1b[0m/' | boxes -d ansi -s "$width"
    else
      printf "%s\n" "$out"
    fi
  fi
  return "$rc"
}

do_status_pretty() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    echo "Not a git repository." >&2; exit 128; }

  local width; width="$(box_width)"
  local staged=() unstaged=() untracked=() conflicts=()
  local line x y path

  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if [[ "$line" == \?\?* ]]; then
      untracked+=("${line#\?\? }"); continue
    fi
    x="${line:0:1}"; y="${line:1:1}"; path="${line:3}"
    if [[ "$x$y" == *U* || ( "$x" = A && "$y" = A ) || ( "$x" = D && "$y" = D ) ]]; then
      conflicts+=("$path"); continue
    fi
    [[ "$x" != " " ]] && staged+=("$path")
    [[ "$y" != " " ]] && unstaged+=("$path")
  done < <(git status --porcelain=v1)

  ((${#staged[@]}))    && print_box green  "✅ Staged changes"    "$width" -- "${staged[@]}"
  ((${#unstaged[@]}))  && print_box yellow "✏️  Unstaged changes" "$width" -- "${unstaged[@]}"
  ((${#untracked[@]})) && print_box cyan   "🆕 Untracked files"    "$width" -- "${untracked[@]}"

  if ((${#conflicts[@]})); then
    print_box red "🛑 Conflicts detected" "$width" -- "${conflicts[@]}"
    printf "Hint: resolve files above, then 'git add <file>' and continue.\n" \
      | sed $'s/^/\x1b[31m/; s/$/\x1b[0m/' | boxes -d ansi
    return 1
  fi

  if ! ((${#staged[@]} + ${#unstaged[@]} + ${#untracked[@]} + ${#conflicts[@]})); then
    printf "Working tree clean ✨\n" | boxes -d ansi
  fi
}

# Pretty push: green box on success, red on error
do_push() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  local width out rc; width="$(box_width)"

  # Check if upstream is configured, if not, set it automatically
  local current_branch upstream
  current_branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"
  upstream="$(git rev-parse --abbrev-ref @{u} 2>/dev/null || echo '')"

  if [[ -z "$upstream" ]]; then
    # No upstream configured, set it automatically
    out="$(git -c color.ui=always push -u origin "$current_branch" "$@" 2>&1)" || rc=$? || true
  else
    # Upstream exists, push normally
    out="$(git -c color.ui=always push "$@" 2>&1)" || rc=$? || true
  fi
  rc=${rc:-0}

  if [[ $rc -eq 0 ]]; then
    # On success, show summary in green ANSI box (rainbow optional)
    if has lolcat; then
      printf "✅ Push successful\n\n%s\n" "$out" \
        | boxes -d ansi -s "$width" \
        | sed $'s/^/\x1b[32m/; s/$/\x1b[0m/' \
        | lolcat
    else
      printf "✅ Push successful\n\n%s\n" "$out" \
        | boxes -d ansi -s "$width" \
        | sed $'s/^/\x1b[32m/; s/$/\x1b[0m/'
    fi
  else
    # On error, show raw output in red ANSI box (don't hide details)
    printf "%s\n" "$out" \
      | boxes -d ansi -s "$width" \
      | sed $'s/^/\x1b[31m/; s/$/\x1b[0m/'
  fi
  return "$rc"
}

# Pretty commit: run commit, then show --stat for HEAD in a box
do_commit_pretty() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    echo "Not a git repository." >&2; exit 128; }

  local width out rc; width="$(box_width)"

  # Run commit (this may open an editor if no -m is provided)
  out="$(git -c color.ui=always commit "$@" 2>&1)" || rc=$? || true
  rc=${rc:-0}

  if [[ $rc -eq 0 ]]; then
    # After a successful commit, show one-line + stat for HEAD
    local stat
    stat="$(git -c color.ui=always show --stat --pretty=format:'%C(bold)%h%Creset %s %C(dim)(%cr)%Creset%n' -1)"
    printf "✨ Commit created successfully ✨\n\n%s\n" "$stat" \
      | boxes -d ansi -s "$width"
  else
    # Print the original commit output (errors, hooks, etc.)
    printf "%s\n" "$out"
  fi
  return "$rc"
}

# Pretty commit with automatic -m: automatically adds -m flag
do_commit_m() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    echo "Not a git repository." >&2; exit 128; }

  local width out rc; width="$(box_width)"

  # Automatically add -m flag if not present
  local args=()
  local has_m=false
  for arg in "$@"; do
    if [[ "$arg" == "-m" ]]; then
      has_m=true
      args+=("$arg")
    elif [[ "$arg" == "--message" ]]; then
      has_m=true
      args+=("$arg")
    else
      args+=("$arg")
    fi
  done

  # If no -m flag found, add it with the first argument as message
  if [[ "$has_m" == false && "$#" -gt 0 ]]; then
    args=("-m" "${args[@]}")
  fi

  # Run commit with the modified arguments
  out="$(git -c color.ui=always commit "${args[@]}" 2>&1)" || rc=$? || true
  rc=${rc:-0}

  if [[ $rc -eq 0 ]]; then
    # After a successful commit, show one-line + stat for HEAD
    local stat
    stat="$(git -c color.ui=always show --stat --pretty=format:'%C(bold)%h%Creset %s %C(dim)(%cr)%Creset%n' -1)"
    printf "✨ Commit created successfully ✨\n\n%s\n" "$stat" \
      | boxes -d ansi -s "$width"
  else
    # Print the original commit output (errors, hooks, etc.)
    printf "%s\n" "$out"
  fi
  return "$rc"
}

# Pretty branches: current branch rainbow (lolcat), others plain (Bash-safe)
do_branches() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  local width; width="$(box_width)"

  # Get branches without git's own colors (we'll colorize ourselves)
  local branches; branches="$(git branch --color=never 2>/dev/null)" || return 1
  [[ -z "$branches" ]] && { echo "No branches found." | boxes -d ansi -s "$width"; return 0; }

  # Build output lines (Bash arrays; no negative indices)
  local -a lines=()
  local line current rainbow_line
  while IFS= read -r line; do
    if [[ "$line" == \** ]]; then
      # Current branch: strip "* " and prefix 👉
      current="${line#* }"
      if has lolcat; then
        rainbow_line="$(printf '👉 %s\n' "$current" | lolcat -f)"
        lines+=("$rainbow_line")
      else
        lines+=("👉 $current")
      fi
    else
      # Other branches: keep plain, trim the first leading space
      lines+=("   ${line# }")
    fi
  done <<<"$branches"

  # Print boxed list (boxes preserves ANSI from lolcat)
  printf "%s\n" "${lines[@]}" | boxes -d ansi -s "$width"
}

# Pretty stash: handles push, list, pop/apply
do_stash() {
  has git || { echo "git-kawaii: git not found" >&2; exit 127; }
  has boxes || { echo "git-kawaii: boxes not found" >&2; exit 127; }
  local width; width="$(box_width)"

  local subcmd="${1:-list}"
  shift || true
  case "$subcmd" in
    push)
      local out; out="$(git stash push "$@" 2>&1)" || return $?
      printf "✨ Stash created ✨\n\n%s\n" "$out" | boxes -d ansi -s "$width"
      ;;
    list)
      local out; out="$(git stash list 2>/dev/null)"
      if [[ -z "$out" ]]; then
        printf "No stashes ✨\n" | boxes -d ansi -s "$width"
      else
        printf "%s\n" "$out" | boxes -d ansi -s "$width"
      fi
      ;;
    pop|apply)
      local out; out="$(git stash "$subcmd" "$@" 2>&1)" || return $?
      printf "🌸 Stash %s done 🌸\n\n%s\n" "$subcmd" "$out" | boxes -d ansi -s "$width"
      ;;
    *)
      # Fallback: pass args directly
      exec git stash "$subcmd" "$@"
      ;;
  esac
}

usage() {
  cat <<'EOF'
git-kawaii (drop-in):
  git-kawaii kawaii-status
  git-kawaii kawaii-merge <args>
  git-kawaii kawaii-rebase <args>
  git-kawaii <ANY GIT CMD>  # forwarded to git
EOF
}

cmd="${1:-}"; shift || true
case "$cmd" in
  kawaii-status) do_status_pretty "$@" ;;
  kawaii-merge)  do_merge "$@" ;;
  kawaii-rebase) do_rebase "$@" ;;

  status|s)      do_status_pretty "$@" ;;
  merge|mm)      do_merge "$@" ;;
  rebase|rb)     do_rebase "$@" ;;

  # pretty push for 'push' or git aliases 'p' and 'ps'
  push|ps)     do_push "$@" ;;

  commit)        do_commit_pretty "$@" ;;
  cm)            do_commit_m "$@" ;;
  branches|b)    do_branches "$@" ;;
  stash)         do_stash "$@" ;;

  ""|-h|--help|help) usage ;;
  *) exec git "$cmd" "$@" ;;
esac